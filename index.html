<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>ã‚¹ãƒãƒ¼ãƒˆãƒ•ã‚©ãƒ³å§¿å‹¢åˆ¤å®šï¼ˆå€‹äººå·®å¯¾å¿œç‰ˆï¼‰</title>
  <style>
    :root { --w: 240px; --h: 320px; }
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial, "Noto Sans JP", "Apple Color Emoji", "Segoe UI Emoji";
      font-size: 18px; margin: 0; color: #111; background: #fafafa; }
    header { padding: 12px 16px; background: #fff; border-bottom: 1px solid #eee; position: sticky; top: 0; z-index: 10; }
    h1 { font-size: 20px; margin: 0; }
    main { display: grid; grid-template-columns: 1fr; gap: 12px; padding: 12px; place-items: center; }
    .stage { display: flex; flex-direction: column; gap: 8px; align-items: center; }
    .pair { display: flex; gap: 8px; align-items: center; justify-content: center; flex-direction: row; }
    video, canvas { transform: scaleX(-1); width: var(--w); height: var(--h);
      border: 1px solid #ddd; background: #000; border-radius: 6px; }
    .controls { display: flex; flex-wrap: wrap; gap: 8px; justify-content: center; }
    button { font-size: 15px; padding: 8px 14px; border-radius: 10px; border: 1px solid #ccc; background: #fff; cursor: pointer; }
    button.primary { background: #0ea5e9; color: #fff; border-color: #0ea5e9; }
    button:disabled { opacity: .6; cursor: not-allowed; }
    .panel { width: min(680px, 92vw); background: #fff; border: 1px solid #eee; border-radius: 12px; padding: 12px; }
    .row { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; white-space: pre-line; }
    #warning { font-size: 24px; font-weight: 800; text-align: center; margin: 4px 0 0; }
    .ok { color: #16a34a; } .bad { color: #dc2626; }
    .hint { color: #666; font-size: 13px; }
    .badge { display:inline-block; padding:2px 8px; border-radius:999px; background:#f1f5f9; font-size:12px; }
    @media (max-width: 760px) { .pair { flex-direction: column; flex-wrap: nowrap; } }
    #canvas { display: none; }

    /* â–¼ æ„Ÿåº¦èª¿æ•´ãƒ‘ãƒãƒ« â–¼ */
    .sensitivity-section {
      background: #f8fafc;
      border: 1px solid #e2e8f0;
      border-radius: 8px;
      padding: 14px;
      margin-top: 12px;
    }
    .sensitivity-section h3 {
      margin: 0 0 10px;
      font-size: 16px;
      color: #334155;
    }
    .slider-row {
      display: flex;
      align-items: center;
      gap: 12px;
      margin-bottom: 10px;
    }
    .slider-row label {
      flex: 0 0 140px;
      font-size: 14px;
      color: #475569;
    }
    .slider-row input[type="range"] {
      flex: 1;
      height: 6px;
      border-radius: 3px;
      background: #cbd5e1;
      outline: none;
      -webkit-appearance: none;
    }
    .slider-row input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 16px;
      height: 16px;
      border-radius: 50%;
      background: #0ea5e9;
      cursor: pointer;
    }
    .slider-row input[type="range"]::-moz-range-thumb {
      width: 16px;
      height: 16px;
      border-radius: 50%;
      background: #0ea5e9;
      cursor: pointer;
      border: none;
    }
    .slider-value {
      flex: 0 0 50px;
      text-align: right;
      font-family: ui-monospace, monospace;
      font-size: 14px;
      font-weight: 600;
      color: #0ea5e9;
    }
    .preset-row {
      display: flex;
      gap: 6px;
      margin-top: 10px;
      flex-wrap: wrap;
    }
    .preset-row button {
      font-size: 13px;
      padding: 6px 12px;
    }

    /* â–¼ YouTubeç”¨ã‚¹ã‚¿ã‚¤ãƒ« â–¼ */
    input[type="url"] {
      width: min(400px, 90vw);
      padding: 8px;
      font-size: 16px;
      box-sizing: border-box;
    }
    .yt-controls {
      margin-top: 8px;
      margin-bottom: 8px;
      display: flex;
      justify-content: center;
      gap: 6px;
      flex-wrap: wrap;
    }
    iframe {
      width: 100%;
      max-width: 640px;
      aspect-ratio: 16/9;
      border: none;
      border-radius: 8px;
      background: #000;
    }
  </style>
</head>
<body>
  <header>
    <h1>ã‚¹ãƒãƒ¼ãƒˆãƒ•ã‚©ãƒ³å§¿å‹¢åˆ¤å®š <span class="badge">å€‹äººå·®å¯¾å¿œç‰ˆ</span></h1>
  </header>

  <main>
    <section class="stage">
      <div class="controls">
        <button id="startBtn" class="primary">æ¸¬å®šé–‹å§‹</button>
        <button id="calibBtn" disabled>æ­£ã—ã„å§¿å‹¢ã®åŸºæº–</button>
        <button id="resetBtn" disabled>è§£é™¤</button>
      </div>
      <div class="pair">
        <video id="video" autoplay muted playsinline></video>
        <canvas id="canvas"></canvas>
      </div>
    </section>

    <section class="panel">
      <div id="warning" class="ok">æ¸¬å®šå¾…æ©Ÿä¸­</div>
      <div class="row">
        <div>
          <h3>ç¾åœ¨å€¤</h3>
          <div id="output" class="mono">èª­ã¿å–ã‚Šä¸­...</div>
        </div>
      </div>
      <p class="hint">ä½¿ã„æ–¹ï¼š<strong>æ¸¬å®šé–‹å§‹</strong> â†’ å€‹äººå·®ãŒå‡ºã‚‹å ´åˆã¯æ­£ã—ã„å§¿å‹¢ã§ <strong>åŸºæº–ãƒœã‚¿ãƒ³</strong> ã‚’æŠ¼ã—ã€3ç§’é™æ­¢ â†’ ä¸è¦ãªã‚‰ <strong>è§£é™¤</strong>ã€‚iOS ã¯é–‹å§‹æ™‚ã«ã‚»ãƒ³ã‚µãƒ¼è¨±å¯ãŒå¿…è¦ã§ã™ã€‚</p>

      <!-- â–¼ æ„Ÿåº¦èª¿æ•´ãƒ‘ãƒãƒ« â–¼ -->
      <div class="sensitivity-section">
        <h3>âš™ï¸ æ„Ÿåº¦èª¿æ•´ï¼ˆå€‹äººå·®å¯¾å¿œï¼‰</h3>
        
        <div class="slider-row">
          <label>è¿‘è·é›¢é–¾å€¤:</label>
          <input type="range" id="pitchThreshold1" min="15" max="45" step="1" value="30">
          <span class="slider-value" id="pitchThreshold1Value">30Â°</span>
        </div>
        
        <div class="slider-row">
          <label>é€šå¸¸è·é›¢é–¾å€¤:</label>
          <input type="range" id="pitchThreshold2" min="25" max="60" step="1" value="40">
          <span class="slider-value" id="pitchThreshold2Value">40Â°</span>
        </div>
        
        <div class="slider-row">
          <label>æ­£é¢åˆ¤å®šæ™‚é–¾å€¤:</label>
          <input type="range" id="straightThreshold" min="10" max="40" step="1" value="25">
          <span class="slider-value" id="straightThresholdValue">25Â°</span>
        </div>
        
        <div class="slider-row">
          <label>é¡”å‘ãæ„Ÿåº¦:</label>
          <input type="range" id="dirSensitivity" min="0.5" max="2.0" step="0.1" value="1.0">
          <span class="slider-value" id="dirSensitivityValue">1.0x</span>
        </div>
        
        <div class="slider-row">
          <label>è·é›¢åˆ¤å®šæ„Ÿåº¦:</label>
          <input type="range" id="proxSensitivity" min="0.5" max="2.0" step="0.1" value="1.0">
          <span class="slider-value" id="proxSensitivityValue">1.0x</span>
        </div>

        <div class="preset-row">
          <button onclick="applyPreset('strict')">å³ã—ã‚</button>
          <button onclick="applyPreset('normal')">æ¨™æº–</button>
          <button onclick="applyPreset('relaxed')">ã‚†ã‚‹ã‚</button>
          <button onclick="saveSettings()">è¨­å®šä¿å­˜</button>
          <button onclick="loadSettings()">è¨­å®šèª­è¾¼</button>
        </div>
        
        <p class="hint" style="margin: 8px 0 0;">
          è­¦å‘ŠãŒå‡ºã™ãã‚‹å ´åˆã¯é–¾å€¤ã‚’å¤§ããã€å‡ºã«ãã„å ´åˆã¯å°ã•ãã—ã¦ãã ã•ã„ã€‚<br>
          è¨­å®šã¯è‡ªå‹•ä¿å­˜ã•ã‚Œã€ãƒ­ã‚°ã«ã‚‚è¨˜éŒ²ã•ã‚Œã¾ã™ã€‚
        </p>
      </div>
      <!-- â–² æ„Ÿåº¦èª¿æ•´ãƒ‘ãƒãƒ« â–² -->

      <!-- â–¼ ãƒ­ã‚°æ“ä½œUI â–¼ -->
      <div class="controls" style="margin-top:12px">
        <button id="logStartBtn">ãƒ­ã‚°é–‹å§‹</button>
        <button id="logStopBtn" disabled>ãƒ­ã‚°åœæ­¢</button>
        <button id="exportCsvBtn">CSVã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆ</button>
        <button id="clearLogBtn">ãƒ­ã‚°å…¨å‰Šé™¤</button>
      </div>
      <!-- â–² ãƒ­ã‚°æ“ä½œUI â–² -->
    </section>

    <!-- â–¼ YouTube éŸ³ã‚ã‚Šå†ç”Ÿãƒ‘ãƒãƒ« â–¼ -->
    <section class="panel">
      <h3>YouTubeéŸ³ã‚ã‚Šå†ç”Ÿãƒ†ã‚¹ãƒˆ</h3>
      <div class="yt-controls">
        <input id="ytUrl" type="url" placeholder="YouTubeã®URLã‚’è²¼ã‚Šä»˜ã‘">
        <button id="loadYtBtn">èª­ã¿è¾¼ã¿</button>
      </div>
      <iframe id="ytPlayer"
              allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture"
              allowfullscreen></iframe>
      <p class="hint">
        ğŸ”Š ã€Œèª­ã¿è¾¼ã¿ã€ãƒœã‚¿ãƒ³ã‚’æŠ¼ã™ã¨éŸ³ä»˜ãã§è‡ªå‹•å†ç”Ÿã‚’è©¦ã¿ã¾ã™ã€‚<br>
        iPhoneã‚„Safariã§ã¯è‡ªå‹•å†ç”ŸãŒç„¡éŸ³ã¾ãŸã¯åœæ­¢ã™ã‚‹å ´åˆãŒã‚ã‚Šã¾ã™ã€‚<br>
        ãã®å ´åˆã¯ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã® â–¶ ãƒœã‚¿ãƒ³ã‚’æŠ¼ã™ã¨éŸ³ãŒå‡ºã¾ã™ã€‚
      </p>
    </section>
    <!-- â–² YouTube éŸ³ã‚ã‚Šå†ç”Ÿãƒ‘ãƒãƒ« â–² -->
  </main>

  <!-- MediaPipe -->
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/face_mesh.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>

  <script>
    // ========== è¨­å®š/çŠ¶æ…‹ ==========
    const PARAMS = {
      alphaPitch: 0.25, alphaRoll: 0.25, alphaYdiff: 0.3, alphaNoseZ: 0.25,
      calibYdiff: null, calibNoseZ: null,
      // æ—¢å­˜ã—ãã„å€¤ï¼ˆè·é›¢ãƒ»ãƒ’ã‚¹ãƒ†ãƒªã‚·ã‚¹ç­‰ã§ä½¿ç”¨ï¼‰
      absExitBand: 0.02,
      closeEnter: -0.035, closeExit: -0.015, farEnter: 0.020, farExit: 0.005,
      absCloseEnter: -0.15, absFarEnter: -0.10, absZExitBand: 0.02,
      sustainMs: 10, clearMs: 10,
      // è­¦å‘ŠéŸ³è¨­å®š
      beep: { intervalMs: 500, freq: 880, dur: 0.3, gain: 0.08 },
      // â˜… æ„Ÿåº¦èª¿æ•´ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿
      pitchThreshold1: 30,   // é¡”ãŒè¿‘ã„æ™‚ã®é–¾å€¤
      pitchThreshold2: 40,   // é€šå¸¸è·é›¢ã®é–¾å€¤
      straightThreshold: 25, // dir='straight'æ™‚ã®é–¾å€¤
      dirSensitivity: 1.0,   // é¡”å‘ãåˆ¤å®šæ„Ÿåº¦
      proxSensitivity: 1.0,  // è·é›¢åˆ¤å®šæ„Ÿåº¦
    };

    const video  = document.getElementById('video');
    const canvas = document.getElementById('canvas');
    const ctx    = canvas.getContext('2d');
    const output = document.getElementById('output');
    const warning= document.getElementById('warning');
    const startBtn = document.getElementById('startBtn');
    const calibBtn = document.getElementById('calibBtn');
    const resetBtn = document.getElementById('resetBtn');

    let rawPitch=0, rawRoll=0;
    let sPitch=0, sRoll=0, sYdiff=null, sNoseZ=null;
    let faceState = { dir: 'straight', prox: 'é€šå¸¸è·é›¢' };
    let bentState = false;
    let enterStart = null, exitStart  = null;
    let wasDown = false, wasUp = false, wasClose = false, wasFar = false;

    // â˜… 3ç§’ã‚­ãƒ£ãƒªãƒ–ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³çŠ¶æ…‹
    let calibMode = false;
    let calibSamples = [];
    let calibStartTs = 0;

    // UIæœ€é©åŒ–
    let lastWarnText = null, lastWarnBad = null;
    let camera = null;
    let lastInferenceTs = 0; // FPSåˆ¶é™

    // é¡”æ¤œå‡ºãƒ•ãƒ©ã‚°
    let faceDetected = false;

    // ======== è­¦å‘ŠéŸ³ï¼ˆWeb Audioï¼‰ ========
    let audioCtx = null;
    let beepInterval = null;

    function ensureAudio() {
      try {
        if (!audioCtx) {
          audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        }
        if (audioCtx.state === 'suspended') {
          audioCtx.resume?.();
        }
      } catch (e) {
        console.warn('AudioContext åˆæœŸåŒ–ã«å¤±æ•—:', e);
        audioCtx = null;
      }
    }

    function playBeep() {
      if (!audioCtx) return;
      const { freq, dur, gain } = PARAMS.beep;
      const osc = audioCtx.createOscillator();
      const g   = audioCtx.createGain();
      osc.type = 'sine';
      osc.frequency.setValueAtTime(freq, audioCtx.currentTime);
      g.gain.setValueAtTime(gain, audioCtx.currentTime);
      osc.connect(g).connect(audioCtx.destination);
      osc.start();
      osc.stop(audioCtx.currentTime + dur);
      osc.onended = () => { try { osc.disconnect(); g.disconnect(); } catch {} };
    }

    function startBeepLoop() {
      if (beepInterval) return;
      playBeep(); // å…¥ã‚Šã§1å›
      beepInterval = setInterval(playBeep, PARAMS.beep.intervalMs);
    }

    function stopBeepLoop() {
      if (beepInterval) { clearInterval(beepInterval); beepInterval = null; }
    }

    // ======== æ„Ÿåº¦èª¿æ•´UI ========
    const pitchThreshold1Slider = document.getElementById('pitchThreshold1');
    const pitchThreshold1Value = document.getElementById('pitchThreshold1Value');
    const pitchThreshold2Slider = document.getElementById('pitchThreshold2');
    const pitchThreshold2Value = document.getElementById('pitchThreshold2Value');
    const straightThresholdSlider = document.getElementById('straightThreshold');
    const straightThresholdValue = document.getElementById('straightThresholdValue');
    const dirSensitivitySlider = document.getElementById('dirSensitivity');
    const dirSensitivityValue = document.getElementById('dirSensitivityValue');
    const proxSensitivitySlider = document.getElementById('proxSensitivity');
    const proxSensitivityValue = document.getElementById('proxSensitivityValue');

    pitchThreshold1Slider.addEventListener('input', (e) => {
      PARAMS.pitchThreshold1 = parseInt(e.target.value);
      pitchThreshold1Value.textContent = PARAMS.pitchThreshold1 + 'Â°';
    });

    pitchThreshold2Slider.addEventListener('input', (e) => {
      PARAMS.pitchThreshold2 = parseInt(e.target.value);
      pitchThreshold2Value.textContent = PARAMS.pitchThreshold2 + 'Â°';
    });

    straightThresholdSlider.addEventListener('input', (e) => {
      PARAMS.straightThreshold = parseInt(e.target.value);
      straightThresholdValue.textContent = PARAMS.straightThreshold + 'Â°';
    });

    dirSensitivitySlider.addEventListener('input', (e) => {
      PARAMS.dirSensitivity = parseFloat(e.target.value);
      dirSensitivityValue.textContent = PARAMS.dirSensitivity.toFixed(1) + 'x';
    });

    proxSensitivitySlider.addEventListener('input', (e) => {
      PARAMS.proxSensitivity = parseFloat(e.target.value);
      proxSensitivityValue.textContent = PARAMS.proxSensitivity.toFixed(1) + 'x';
    });

    // ãƒ—ãƒªã‚»ãƒƒãƒˆé©ç”¨
    window.applyPreset = function(preset) {
      if (preset === 'strict') {
        PARAMS.pitchThreshold1 = 20;
        PARAMS.pitchThreshold2 = 30;
        PARAMS.straightThreshold = 15;
        PARAMS.dirSensitivity = 1.5;
        PARAMS.proxSensitivity = 1.5;
      } else if (preset === 'normal') {
        PARAMS.pitchThreshold1 = 30;
        PARAMS.pitchThreshold2 = 40;
        PARAMS.straightThreshold = 25;
        PARAMS.dirSensitivity = 1.0;
        PARAMS.proxSensitivity = 1.0;
      } else if (preset === 'relaxed') {
        PARAMS.pitchThreshold1 = 40;
        PARAMS.pitchThreshold2 = 50;
        PARAMS.straightThreshold = 35;
        PARAMS.dirSensitivity = 0.7;
        PARAMS.proxSensitivity = 0.7;
      }
      updateSliders();
      saveSettings(); // ãƒ—ãƒªã‚»ãƒƒãƒˆé©ç”¨æ™‚ã«è‡ªå‹•ä¿å­˜
    };

    function updateSliders() {
      pitchThreshold1Slider.value = PARAMS.pitchThreshold1;
      pitchThreshold1Value.textContent = PARAMS.pitchThreshold1 + 'Â°';
      pitchThreshold2Slider.value = PARAMS.pitchThreshold2;
      pitchThreshold2Value.textContent = PARAMS.pitchThreshold2 + 'Â°';
      straightThresholdSlider.value = PARAMS.straightThreshold;
      straightThresholdValue.textContent = PARAMS.straightThreshold + 'Â°';
      dirSensitivitySlider.value = PARAMS.dirSensitivity;
      dirSensitivityValue.textContent = PARAMS.dirSensitivity.toFixed(1) + 'x';
      proxSensitivitySlider.value = PARAMS.proxSensitivity;
      proxSensitivityValue.textContent = PARAMS.proxSensitivity.toFixed(1) + 'x';
    }

    // è¨­å®šã®ä¿å­˜ãƒ»èª­è¾¼
    window.saveSettings = function() {
      const settings = {
        pitchThreshold1: PARAMS.pitchThreshold1,
        pitchThreshold2: PARAMS.pitchThreshold2,
        straightThreshold: PARAMS.straightThreshold,
        dirSensitivity: PARAMS.dirSensitivity,
        proxSensitivity: PARAMS.proxSensitivity,
      };
      localStorage.setItem('posture-sensitivity', JSON.stringify(settings));
      // æ§ãˆã‚ãªé€šçŸ¥
      const prev = lastWarnText;
      setWarning(false, 'è¨­å®šã‚’ä¿å­˜ã—ã¾ã—ãŸ');
      setTimeout(() => {
        if (faceDetected) {
          setWarning(bentState, bentState ? 'é¦–ãŒæ›²ãŒã£ã¦ã„ã¾ã™' : 'é¦–ã¯æ›²ãŒã£ã¦ã„ã¾ã›ã‚“');
        }
      }, 1500);
    };

    window.loadSettings = function() {
      try {
        const saved = localStorage.getItem('posture-sensitivity');
        if (!saved) {
          alert('ä¿å­˜ã•ã‚ŒãŸè¨­å®šãŒã‚ã‚Šã¾ã›ã‚“');
          return;
        }
        const settings = JSON.parse(saved);
        PARAMS.pitchThreshold1 = settings.pitchThreshold1 || 30;
        PARAMS.pitchThreshold2 = settings.pitchThreshold2 || 40;
        PARAMS.straightThreshold = settings.straightThreshold || 25;
        PARAMS.dirSensitivity = settings.dirSensitivity || 1.0;
        PARAMS.proxSensitivity = settings.proxSensitivity || 1.0;
        updateSliders();
        
        const prev = lastWarnText;
        setWarning(false, 'è¨­å®šã‚’èª­ã¿è¾¼ã¿ã¾ã—ãŸ');
        setTimeout(() => {
          if (faceDetected) {
            setWarning(bentState, bentState ? 'é¦–ãŒæ›²ãŒã£ã¦ã„ã¾ã™' : 'é¦–ã¯æ›²ãŒã£ã¦ã„ã¾ã›ã‚“');
          }
        }, 1500);
      } catch {
        alert('è¨­å®šã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸ');
      }
    };

    // ãƒšãƒ¼ã‚¸èª­ã¿è¾¼ã¿æ™‚ã«ä¿å­˜ã•ã‚ŒãŸè¨­å®šã‚’è‡ªå‹•å¾©å…ƒ
    function autoLoadSettings() {
      try {
        const saved = localStorage.getItem('posture-sensitivity');
        if (saved) {
          const settings = JSON.parse(saved);
          PARAMS.pitchThreshold1 = settings.pitchThreshold1 || 30;
          PARAMS.pitchThreshold2 = settings.pitchThreshold2 || 40;
          PARAMS.straightThreshold = settings.straightThreshold || 25;
          PARAMS.dirSensitivity = settings.dirSensitivity || 1.0;
          PARAMS.proxSensitivity = settings.proxSensitivity || 1.0;
          updateSliders();
        }
      } catch {}
    }

    // ========== ã‚»ãƒ³ã‚µãƒ¼ ==========
    function handleOrientation(e){
      rawPitch = (e.beta  ?? 0);
      rawRoll  = (e.gamma ?? 0);
      sPitch = PARAMS.alphaPitch * rawPitch + (1 - PARAMS.alphaPitch) * sPitch;
      sRoll  = PARAMS.alphaRoll  * rawRoll  + (1 - PARAMS.alphaRoll ) * sRoll;
    }

    // ========== FaceMesh ==========
    const faceMesh = new FaceMesh({ locateFile: f => `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${f}` });
    faceMesh.setOptions({ maxNumFaces: 1, refineLandmarks: false, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5 });

    faceMesh.onResults(results => {
      // FPSåˆ¶é™ï¼ˆ10fpsï¼‰
      const now = performance.now();
      if (now - lastInferenceTs < 100) return;
      lastInferenceTs = now;

      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.drawImage(results.image, 0, 0, canvas.width, canvas.height);

      if (!results.multiFaceLandmarks || results.multiFaceLandmarks.length === 0) {
        faceDetected = false;
        setWarning(true, 'é¡”ãŒæ¤œå‡ºã§ãã¾ã›ã‚“');
        output.textContent = 'é¡”ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“';
        return;
      }
      faceDetected = true;

      const lm = results.multiFaceLandmarks[0];
      const nose = lm[1];
      const chin = lm[152];

      drawPoint(nose, '#22c55e');
      drawPoint(chin, '#2563eb');

      const yDiff = (chin.y - nose.y);
      const noseZ = nose.z;

      sYdiff = (sYdiff == null) ? yDiff : PARAMS.alphaYdiff * yDiff + (1 - PARAMS.alphaYdiff) * sYdiff;
      sNoseZ = (sNoseZ == null) ? noseZ : PARAMS.alphaNoseZ * noseZ + (1 - PARAMS.alphaNoseZ) * sNoseZ;

      // â˜… 3ç§’ã‚­ãƒ£ãƒªãƒ–ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³å‡¦ç†
      if (calibMode) {
        const elapsed = performance.now() - calibStartTs;
        calibSamples.push({ y: sYdiff, z: sNoseZ });
        if (elapsed >= 3000) {
          const avgY = calibSamples.reduce((s, x) => s + x.y, 0) / calibSamples.length;
          const avgZ = calibSamples.reduce((s, x) => s + x.z, 0) / calibSamples.length;
          PARAMS.calibYdiff = avgY;
          PARAMS.calibNoseZ = avgZ;
          saveCalibration(avgY, avgZ);
          calibMode = false;
          calibSamples = [];
          setWarning(false, 'ã‚­ãƒ£ãƒªãƒ–ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ãŒå®Œäº†ã—ã¾ã—ãŸï¼');
        }
        return;
      }

      // é¡”å‘ã & è·é›¢ã®åˆ†é¡
      const dir = classifyDirection();
      faceState.dir = dir;
      const prox = classifyProximity(sNoseZ);
      faceState.prox = prox;

      // ã‚¹ãƒãƒ›è§’åº¦ã‚‚è€ƒæ…®ã—ãŸé¦–æ›²ãŒã‚Šæœ€çµ‚åˆ¤å®š
      const pitchAbs = Math.abs(sPitch);
      const isBentNow = isBent(faceState.dir, faceState.prox, pitchAbs);
      updateSustain(isBentNow);

      // ãƒ‡ãƒãƒƒã‚°å‡ºåŠ›
      const combined = getCombinedForDebug();
      output.textContent =
        `Pitch: ${sPitch.toFixed(2)}Â°\n` +
        `Roll:  ${sRoll.toFixed(2)}Â°\n` +
        `yDiff(å¹³æ»‘): ${sYdiff.toFixed(4)}\n` +
        `noseZ(å¹³æ»‘): ${sNoseZ.toFixed(4)}\n` +
        `combined(y+z): ${combined.toFixed(4)}\n` +
        `é¡”å‘ã: ${faceState.dir}\n` +
        `é¡”è·é›¢: ${faceState.prox}\n` +
        `[æ„Ÿåº¦] é–¾å€¤:${PARAMS.pitchThreshold1}Â°/${PARAMS.pitchThreshold2}Â° æ­£é¢:${PARAMS.straightThreshold}Â° å‘ã:${PARAMS.dirSensitivity.toFixed(1)}x è·é›¢:${PARAMS.proxSensitivity.toFixed(1)}x`;

      // ãƒ­ã‚°è¨˜éŒ²ï¼ˆ1ç§’ç²’åº¦ï¼‰
      addLogSample();
    });

    function drawPoint(normLandmark, color) {
      const x = normLandmark.x * canvas.width;
      const y = normLandmark.y * canvas.height;
      ctx.beginPath(); ctx.arc(x, y, 4, 0, Math.PI * 2); ctx.fillStyle = color; ctx.fill();
    }

    // === combined(y+z) ã‚’è¿”ã™ï¼ˆã‚­ãƒ£ãƒªãƒ–æœ‰ç„¡ã«å¯¾å¿œï¼‰
    function getCombinedForDebug(){
      if (PARAMS.calibYdiff != null && PARAMS.calibNoseZ != null){
        return (sYdiff - PARAMS.calibYdiff) + (sNoseZ - PARAMS.calibNoseZ);
      }
      return (sYdiff ?? 0) + (sNoseZ ?? 0);
    }

    // â˜… é¡”å‘ãï¼šyDiff + noseZ ã§åˆ¤å®šï¼ˆãƒ’ã‚¹ãƒ†ãƒªã‚·ã‚¹ï¼‰â˜…æ„Ÿåº¦èª¿æ•´å¯¾å¿œ
    function classifyDirection() {
      const band = PARAMS.absExitBand ?? 0.02;
      let combined;

      if (PARAMS.calibYdiff != null && PARAMS.calibNoseZ != null){
        combined = (sYdiff - PARAMS.calibYdiff) + (sNoseZ - PARAMS.calibNoseZ);
      } else {
        combined = (sYdiff ?? 0) + (sNoseZ ?? 0);
      }

      // â˜… æ„Ÿåº¦èª¿æ•´ã‚’åæ˜ 
      const downThreshold = -0.04 * PARAMS.dirSensitivity;
      const upThreshold = 0.03 * PARAMS.dirSensitivity;  // â˜… 0.05 â†’ 0.03 ã«å¤‰æ›´

      if (!wasDown && combined < downThreshold) { wasDown = true; wasUp = false; return 'down'; }
      if (wasDown && combined > downThreshold + band) { wasDown = false; }

      if (!wasUp && combined > upThreshold) { wasUp = true; wasDown = false; return 'up'; }
      if (wasUp && combined < upThreshold - band) { wasUp = false; }

      if (wasDown) return 'down';
      if (wasUp)   return 'up';
      return 'straight';
    }

    function classifyProximity(z) {
      // â˜… æ„Ÿåº¦èª¿æ•´ã‚’åæ˜ 
      if (PARAMS.calibNoseZ != null) {
        const dz = z - PARAMS.calibNoseZ;
        const closeEnter = PARAMS.closeEnter * PARAMS.proxSensitivity;
        const closeExit = PARAMS.closeExit * PARAMS.proxSensitivity;
        const farEnter = PARAMS.farEnter * PARAMS.proxSensitivity;
        const farExit = PARAMS.farExit * PARAMS.proxSensitivity;

        if (!wasClose && dz <= closeEnter) { wasClose = true; wasFar = false; return 'é¡”ãŒè¿‘ã„'; }
        if (wasClose && dz >= closeExit)   { wasClose = false; }
        if (!wasFar && dz >= farEnter)     { wasFar = true; wasClose = false; return 'é¡”ãŒé ã„'; }
        if (wasFar && dz <= farExit)       { wasFar = false; }
        if (wasClose) return 'é¡”ãŒè¿‘ã„';
        if (wasFar)   return 'é¡”ãŒé ã„';
        return 'é€šå¸¸è·é›¢';
      } else {
        const close = PARAMS.absCloseEnter * PARAMS.proxSensitivity;
        const far = PARAMS.absFarEnter * PARAMS.proxSensitivity;
        const band = PARAMS.absZExitBand;

        if (!wasClose && z < close) { wasClose = true; wasFar = false; return 'é¡”ãŒè¿‘ã„'; }
        if (wasClose && z > close + band) { wasClose = false; }
        if (!wasFar && z > far) { wasFar = true; wasClose = false; return 'é¡”ãŒé ã„'; }
        if (wasFar && z < far - band) { wasFar = false; }
        if (wasClose) return 'é¡”ãŒè¿‘ã„';
        if (wasFar)   return 'é¡”ãŒé ã„';
        return 'é€šå¸¸è·é›¢';
      }
    }

    // â˜… æœ€çµ‚åˆ¤å®šï¼ˆç«¯æœ«è§’åº¦ã‚‚è€ƒæ…®ï¼‰â˜…æ„Ÿåº¦èª¿æ•´å¯¾å¿œï¼†æ”¹å–„ç‰ˆ
    function isBent(dir, prox, pitchAbs){
      // â˜… èª¿æ•´å¯èƒ½ãªé–¾å€¤ã‚’ä½¿ç”¨
      if (prox === 'é¡”ãŒè¿‘ã„' && pitchAbs <= PARAMS.pitchThreshold1) return true;
      
      // â˜… æ”¹å–„ï¼šdir='straight'ã®å ´åˆã¯ã€ã‚ˆã‚Šå³ã—ã„æ¡ä»¶ã§åˆ¤å®š
      if (pitchAbs <= PARAMS.pitchThreshold2) {
        if (dir === 'down') return true;  // downã¯ç¢ºå®Ÿã«è­¦å‘Š
        if (dir === 'straight' && pitchAbs <= PARAMS.straightThreshold) return true;  // straightã¯èª¿æ•´å¯èƒ½ãªé–¾å€¤ä»¥ä¸‹ã®ã¿
        return false;
      }
      
      return (dir === 'down');
    }

    // â˜… ä¿®æ­£ï¼šè¡¨ç¤ºã¯æ¯ãƒ•ãƒ¬ãƒ¼ãƒ åŒæœŸã€‚é¡”ãŒè¦‹ãˆã¦ã„ã‚Œã° bentState ã®å†…å®¹ã§å¸¸ã«ä¸Šæ›¸ãã€‚
    function updateSustain(isNow){
      const t = performance.now();
      if (isNow) {
        if (enterStart == null) enterStart = t;
        exitStart = null;
        const elapsed = t - enterStart;
        if (!bentState && elapsed >= PARAMS.sustainMs) {
          bentState = true;
          setWarning(true, 'é¦–ãŒæ›²ãŒã£ã¦ã„ã¾ã™');
          startBeepLoop();
        }
      } else {
        if (exitStart == null) exitStart = t;
        enterStart = null;
        const elapsed = t - exitStart;
        if (bentState && elapsed >= PARAMS.clearMs) {
          bentState = false;
          setWarning(false, 'é¦–ã¯æ›²ãŒã£ã¦ã„ã¾ã›ã‚“');
          stopBeepLoop();
        }
      }

      // â˜… æ¯ãƒ•ãƒ¬ãƒ¼ãƒ ï¼šé¡”ãŒè¦‹ãˆã¦ã„ã‚‹é–“ã¯æœ€æ–°çŠ¶æ…‹ã‚’åæ˜ 
      if (faceDetected) {
        setWarning(bentState, bentState ? 'é¦–ãŒæ›²ãŒã£ã¦ã„ã¾ã™' : 'é¦–ã¯æ›²ãŒã£ã¦ã„ã¾ã›ã‚“');
      }
    }

    function setWarning(bad, text){
      if (text === lastWarnText && bad === lastWarnBad) return;
      lastWarnText = text; lastWarnBad = bad;
      warning.textContent = text;
      warning.className = bad ? 'bad' : 'ok';
    }

    async function initCamera(){
      const stream = await navigator.mediaDevices.getUserMedia({
        video: { facingMode: 'user', width: {ideal: 640}, height: {ideal: 480} },
        audio: false
      });
      video.srcObject = stream;
      await new Promise(r => video.onloadedmetadata = r);
      canvas.width = video.videoWidth; canvas.height = video.videoHeight;
    }

    async function startAll(){
      if (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function'){
        try {
          const res = await DeviceOrientationEvent.requestPermission();
          if (res === 'granted') window.addEventListener('deviceorientation', handleOrientation);
          else { output.textContent = 'ã‚»ãƒ³ã‚µãƒ¼ã®åˆ©ç”¨ãŒè¨±å¯ã•ã‚Œã¾ã›ã‚“ã§ã—ãŸã€‚'; return; }
        } catch { output.textContent = 'ã‚»ãƒ³ã‚µãƒ¼è¨±å¯ã§ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚'; return; }
      } else {
        window.addEventListener('deviceorientation', handleOrientation);
      }

      await initCamera();

      // ãƒ¦ãƒ¼ã‚¶ãƒ¼æ“ä½œç›´å¾Œã«ã‚ªãƒ¼ãƒ‡ã‚£ã‚ªã‚’æœ‰åŠ¹åŒ–ï¼ˆiOSè‡ªå‹•å†ç”Ÿåˆ¶é™å¯¾ç­–ï¼‰
      ensureAudio();

      camera = new Camera(video, {
        onFrame: async () => {
          const t = performance.now();
          if (t - lastInferenceTs >= 100) {
            await faceMesh.send({ image: video });
          }
        },
        width: 640, height: 480
      });
      camera.start();

      startBtn.disabled = true; calibBtn.disabled = false; resetBtn.disabled = false;

      const saved = loadCalibration();
      if (saved) {
        PARAMS.calibYdiff = saved.y; PARAMS.calibNoseZ = saved.z;
        setWarning(false, 'æ¸¬å®šä¸­...');
      } else {
        setWarning(false, 'æ¸¬å®šä¸­...');
      }

      // ã‚¿ãƒ–éè¡¨ç¤ºã§ä¸€æ™‚åœæ­¢ï¼å¾©å¸°
      document.addEventListener('visibilitychange', () => {
        if (!camera) return;
        if (document.hidden) {
          try { camera.stop(); } catch {}
          stopBeepLoop();
        } else {
          try { camera.start(); } catch {}
        }
      }, { passive: true });
    }

    // 3ç§’å¹³å‡ã‚­ãƒ£ãƒªãƒ–
    function calibrate(){
      if (sYdiff == null || sNoseZ == null) {
        setWarning(true, 'ã¾ã å€¤ãŒå®‰å®šã—ã¦ã„ã¾ã›ã‚“ã€‚æ•°ç§’å¾…ã£ã¦ã‹ã‚‰ã‚‚ã†ä¸€åº¦è©¦ã—ã¦ãã ã•ã„');
        return;
      }
      calibMode = true;
      calibSamples = [];
      calibStartTs = performance.now();
      setWarning(false, 'è‰¯ã„å§¿å‹¢ã§3ç§’é–“ãã®ã¾ã¾é™æ­¢ã—ã¦ãã ã•ã„');
    }

    function resetCalibration(){
      PARAMS.calibYdiff = null; PARAMS.calibNoseZ = null;
      calibMode = false;
      calibSamples = [];
      calibStartTs = 0;
      localStorage.removeItem('posture-calib');
      setWarning(false, 'ã‚­ãƒ£ãƒªãƒ–ã‚’è§£é™¤ã—ã¾ã—ãŸ');
    }

    function saveCalibration(y, z){ try { localStorage.setItem('posture-calib', JSON.stringify({ y, z })); } catch {} }
    function loadCalibration(){ try { return JSON.parse(localStorage.getItem('posture-calib')); } catch { return null; } }

    // ============================== ãƒ­ã‚°ä¿å­˜ï¼ˆIndexedDBï¼‰ ==============================
    const DB_NAME = 'posture-db';
    const STORE = 'logs';
    let db = null;

    function openDB(){
      return new Promise((resolve, reject) => {
        const req = indexedDB.open(DB_NAME, 1);
        req.onupgradeneeded = (e) => {
          const _db = e.target.result;
          if (!_db.objectStoreNames.contains(STORE)) {
            const os = _db.createObjectStore(STORE, { keyPath: 'ts' });
            os.createIndex('day', 'day', { unique: false });
            os.createIndex('day_hour', ['day','hour'], { unique: false });
          }
        };
        req.onsuccess = () => { db = req.result; resolve(db); };
        req.onerror = () => reject(req.error);
      });
    }

    function ymdFromTs(ts){
      const d = new Date(ts);
      const y = d.getFullYear();
      const m = String(d.getMonth()+1).padStart(2,'0');
      const day = String(d.getDate()).padStart(2,'0');
      return `${y}-${m}-${day}`;
    }

    // JST(+09:00) ã® ISOé¢¨æ–‡å­—åˆ—ï¼ˆãƒŸãƒªç§’ä»˜ãï¼‰
    function toJstIso(ts){
      const d = new Date(ts);
      const parts = Object.fromEntries(
        new Intl.DateTimeFormat('sv-SE', {
          timeZone: 'Asia/Tokyo',
          year: 'numeric', month: '2-digit', day: '2-digit',
          hour: '2-digit', minute: '2-digit', second: '2-digit',
          hour12: false
        }).formatToParts(d).map(p => [p.type, p.value])
      );
      const ms = String(d.getMilliseconds()).padStart(3,'0');
      return `${parts.year}-${parts.month}-${parts.day}T${parts.hour}:${parts.minute}:${parts.second}.${ms}+09:00`;
    }

    let LOGGING = false;
    let logBuffer = [];
    let lastFlush = 0;
    const LOG_INTERVAL_MS = 1000;
    const FLUSH_MS = 5000;
    let lastLogAt = 0;

    async function addLogSample(){
      if (!LOGGING) return;
      const now = performance.now();
      if (now - lastLogAt < LOG_INTERVAL_MS) return;
      lastLogAt = now;

      const ts = Date.now();
      const d = new Date(ts);
      const entry = {
        ts,
        day: ymdFromTs(ts),
        hour: d.getHours(),
        pitch: sPitch, roll: sRoll,
        y: sYdiff, z: sNoseZ,
        dir: faceState.dir,
        prox: faceState.prox,
        bent: !!bentState,
        // â˜… æ„Ÿåº¦è¨­å®šã‚‚ãƒ­ã‚°ã«è¨˜éŒ²
        pitchThreshold1: PARAMS.pitchThreshold1,
        pitchThreshold2: PARAMS.pitchThreshold2,
        straightThreshold: PARAMS.straightThreshold,
        dirSensitivity: PARAMS.dirSensitivity,
        proxSensitivity: PARAMS.proxSensitivity,
      };
      logBuffer.push(entry);

      if (ts - lastFlush >= FLUSH_MS) {
        await flushLogs();
      }
    }

    async function flushLogs(){
      if (!db || logBuffer.length === 0) return;
      const tx = db.transaction(STORE, 'readwrite');
      const store = tx.objectStore(STORE);
      for (const e of logBuffer) store.put(e);
      await new Promise((res, rej) => { tx.oncomplete = res; tx.onerror = () => rej(tx.error); });
      logBuffer = [];
      lastFlush = Date.now();
    }

    async function exportCSV(){
      await flushLogs();
      if (!db) await openDB();

      const tx = db.transaction(STORE, 'readonly');
      const store = tx.objectStore(STORE);
      const rows = [['ts','iso','day','hour','pitch','roll','y','z','dir','prox','bent','pitchThreshold1','pitchThreshold2','straightThreshold','dirSensitivity','proxSensitivity']];
      const req = store.openCursor();
      await new Promise((resolve, reject) => {
        req.onsuccess = (e) => {
          const cur = e.target.result;
          if (!cur) return resolve();
          const v = cur.value;
          rows.push([
            v.ts,
            toJstIso(v.ts),
            v.day,
            v.hour,
            v.pitch?.toFixed?.(3),
            v.roll?.toFixed?.(3),
            v.y?.toFixed?.(5),
            v.z?.toFixed?.(5),
            v.dir,
            v.prox,
            v.bent ? 1 : 0,
            v.pitchThreshold1 || 30,
            v.pitchThreshold2 || 40,
            v.straightThreshold || 25,
            v.dirSensitivity?.toFixed?.(2) || 1.0,
            v.proxSensitivity?.toFixed?.(2) || 1.0,
          ]);
          cur.continue();
        };
        req.onerror = () => reject(req.error);
      });

      const csv = rows.map(r => r.join(',')).join('\n');
      const blob = new Blob([csv], {type:'text/csv'});
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      const stamp = new Date().toISOString().slice(0,19).replace(/[:T]/g,'-');
      a.href = url; a.download = `posture_logs_${stamp}.csv`;
      document.body.appendChild(a); a.click(); a.remove();
      URL.revokeObjectURL(url);
    }

    async function clearAllLogs(){
      if (!db) await openDB();
      await flushLogs();
      const tx = db.transaction(STORE, 'readwrite');
      tx.objectStore(STORE).clear();
      await new Promise((res, rej) => { tx.oncomplete = res; tx.onerror = () => rej(tx.error); });
      setWarning(false, 'ãƒ­ã‚°ã‚’å…¨å‰Šé™¤ã—ã¾ã—ãŸ');
    }

    // ========== YouTube URL è§£æ ==========
    function parseYouTube(urlStr) {
      try {
        const u = new URL(urlStr);
        const host = u.hostname.replace(/^www\./, '');
        let id = null;
        if (host === 'youtube.com' || host === 'm.youtube.com') {
          if (u.pathname === '/watch') id = u.searchParams.get('v');
          else if (u.pathname.startsWith('/shorts/')) id = u.pathname.split('/')[2];
          else if (u.pathname.startsWith('/live/'))   id = u.pathname.split('/')[2];
        } else if (host === 'youtu.be') {
          id = u.pathname.slice(1);
        }
        return id;
      } catch {
        return null;
      }
    }

    // ========== UIé…ç·š ==========
    window.addEventListener('load', async () => {
      await openDB();
      autoLoadSettings(); // â˜… è¨­å®šã®è‡ªå‹•èª­ã¿è¾¼ã¿

      startBtn.addEventListener('click', startAll);
      calibBtn.addEventListener('click', calibrate);
      resetBtn.addEventListener('click', resetCalibration);

      const logStartBtn  = document.getElementById('logStartBtn');
      const logStopBtn   = document.getElementById('logStopBtn');
      const exportCsvBtn = document.getElementById('exportCsvBtn');
      const clearLogBtn  = document.getElementById('clearLogBtn');

      if (logStartBtn) logStartBtn.addEventListener('click', async ()=>{
        LOGGING = true; lastLogAt = 0; lastFlush = 0;
        output.textContent += '\n[LOG] ãƒ­ã‚°è¨˜éŒ²ã‚’é–‹å§‹ã—ã¾ã—ãŸ';
        logStartBtn.disabled = true; logStopBtn.disabled  = false;
      });

      if (logStopBtn) logStopBtn.addEventListener('click', async ()=>{
        LOGGING = false; await flushLogs();
        output.textContent += '\n[LOG] ãƒ­ã‚°è¨˜éŒ²ã‚’åœæ­¢ã—ã¾ã—ãŸ';
        logStartBtn.disabled = false; logStopBtn.disabled  = true;
      });

      if (exportCsvBtn) exportCsvBtn.addEventListener('click', exportCSV);
      if (clearLogBtn)  clearLogBtn.addEventListener('click', clearAllLogs);

      // YouTube ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼
      const ytUrl = document.getElementById('ytUrl');
      const loadYtBtn = document.getElementById('loadYtBtn');
      const ytPlayer = document.getElementById('ytPlayer');

      if (loadYtBtn && ytUrl && ytPlayer) {
        loadYtBtn.addEventListener('click', () => {
          const id = parseYouTube(ytUrl.value.trim());
          if (!id) {
            alert("URLã‚’æ­£ã—ãèªè­˜ã§ãã¾ã›ã‚“ã§ã—ãŸ");
            return;
          }
          ytPlayer.src = `https://www.youtube.com/embed/${id}?autoplay=1&rel=0`;
        });
      }
    });
  </script>
</body>
</html>
